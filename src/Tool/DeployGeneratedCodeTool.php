<?php
namespace App\Tool;

use Symfony\AI\Agent\Toolbox\Attribute\AsTool;
use Symfony\AI\Platform\Contract\JsonSchema\Attribute\With;
use Symfony\Component\HttpKernel\KernelInterface;
use Symfony\Component\Filesystem\Filesystem;
use Psr\Log\LoggerInterface;

#[AsTool(
    name: 'deploy_generated_code',
    description: 'Generates a deployment script to copy files from the `generated_code` directory to specified target locations in the production project. Requires user confirmation and code review before execution.'
)]
final class DeployGeneratedCodeTool
{
    private string $projectDir;
    private Filesystem $filesystem;
    private LoggerInterface $logger;
    private const GENERATED_CODE_DIR = '/generated_code/';

    public function __construct(KernelInterface $kernel, LoggerInterface $logger)
    {
        $this->projectDir = $kernel->getProjectDir();
        $this->filesystem = new Filesystem();
        $this->logger = $logger;
    }

    /**
     * Generates a shell script to deploy files from the generated_code directory.
     * The script must be reviewed and executed by the user manually.
     *
     * @param array<array{source_file: string, target_path: string}> $filesToDeploy An array of files to deploy.
     *   Each item must have:
     *   - 'source_file': The name of the file in the `generated_code` directory (e.g., "MyNewClass.php").
     *   - 'target_path': The relative path in the production project where the file should be copied (e.g., "src/Service/MyNewClass.php").
     * @return string A message indicating the success or failure of script generation, and instructions for the user.
     */
    public function __invoke(
        #[With(pattern: '/^[^\\/]+\\.(html|js|php|yaml|json|css|md|txt|xml)$/i')]
        array $filesToDeploy
    ): string {
        $generatedCodeAbsolutePath = $this->projectDir . self::GENERATED_CODE_DIR;

        if (!$this->filesystem->exists($generatedCodeAbsolutePath)) {
            $this->logger->error(sprintf('Generated code directory does not exist: %s', $generatedCodeAbsolutePath));
            return 'ERROR: The `generated_code` directory does not exist. No files can be deployed.';
        }

        if (empty($filesToDeploy)) {
            return 'WARNING: No files specified for deployment. Nothing to do.';
        }

        $scriptContent = "#!/bin/bash\n\n";
        $scriptContent .= "# This script was generated by the AI agent to deploy files.\n";
        $scriptContent .= "# PLEASE REVIEW THIS SCRIPT CAREFULLY BEFORE EXECUTION!\n";
        $scriptContent .= "# It will copy files from the 'generated_code' directory to your project's production paths.\n\n";
        $scriptContent .= "GENERATED_CODE_DIR=\"" . escapeshellarg($generatedCodeAbsolutePath) . "\"\n";
        $scriptContent .= "PROJECT_ROOT=\"" . escapeshellarg($this->projectDir) . "\"\n\n";
        $scriptContent .= "echo \"Starting deployment script...\"\n\n";

        $successfulFiles = [];
        $failedFiles = [];

        foreach ($filesToDeploy as $fileInfo) {
            $sourceFile = $fileInfo['source_file'] ?? null;
            $targetPath = $fileInfo['target_path'] ?? null;

            if (!$sourceFile || !$targetPath) {
                $failedFiles[] = 'Invalid file entry (missing source_file or target_path): ' . json_encode($fileInfo);
                continue;
            }

            // Path Traversal Prevention for source_file (already handled by pattern in With attribute, but extra check)
            if (basename($sourceFile) !== $sourceFile) {
                 $failedFiles[] = sprintf('Source file "%s" contains directory traversal characters. Skipping.', $sourceFile);
                 continue;
            }

            $fullSourcePath = $generatedCodeAbsolutePath . $sourceFile;
            $fullTargetPath = $this->projectDir . '/' . ltrim($targetPath, '/'); // Ensure target path is relative to project root

            // Path Traversal Prevention for target_path
            // Canonicalize and ensure target path starts with project root
            $resolvedTargetPath = realpath($this->projectDir . '/' . $targetPath);
            $projectRootResolved = realpath($this->projectDir);

            if ($resolvedTargetPath === false || strpos($resolvedTargetPath, $projectRootResolved) !== 0) {
                 $failedFiles[] = sprintf('Target path "%s" resolves outside project root. Skipping.', $targetPath);
                 continue;
            }


            if (!$this->filesystem->exists($fullSourcePath)) {
                $failedFiles[] = sprintf('Source file "%s" not found in `generated_code` directory.', $sourceFile);
                continue;
            }

            $targetDir = dirname($fullTargetPath);
            $scriptContent .= "echo \"Checking target directory: " . escapeshellarg($targetDir) . "\"\n";
            $scriptContent .= "mkdir -p " . escapeshellarg($targetDir) . "\n";
            $scriptContent .= "if [ ! -d " . escapeshellarg($targetDir) . " ]; then\n";
            $scriptContent .= "    echo \"ERROR: Failed to create target directory " . escapeshellarg($targetDir) . ". Aborting for this file.\"\n";
            $scriptContent .= "else\n";
            $scriptContent .= "    echo \"Copying " . escapeshellarg($sourceFile) . " to " . escapeshellarg($targetPath) . "\"\n";
            $scriptContent .= "    cp " . escapeshellarg($fullSourcePath) . " " . escapeshellarg($fullTargetPath) . "\n";
            $scriptContent .= "    if [ \$? -eq 0 ]; then\n";
            $scriptContent .= "        echo \"Successfully copied " . escapeshellarg($sourceFile) . "\"\n";
            $scriptContent .= "    else\n";
            $scriptContent .= "        echo \"ERROR: Failed to copy " . escapeshellarg($sourceFile) . ". Please check permissions and path.\"\n";
            $scriptContent .= "    fi\n";
            $scriptContent .= "fi\n\n";

            $successfulFiles[] = ['source_file' => $sourceFile, 'target_path' => $targetPath];
        }

        $deploymentScriptFilename = 'deploy_generated_code_' . (new \DateTime())->format('YmdHis') . '.sh';
        $deploymentScriptPath = $generatedCodeAbsolutePath . $deploymentScriptFilename;

        // Save the deployment script
        try {
            file_put_contents($deploymentScriptPath, $scriptContent);
            chmod($deploymentScriptPath, 0755); // Make it executable
            $this->logger->info(sprintf('Deployment script generated: %s', $deploymentScriptPath));
        } catch (\Exception $e) {
            $this->logger->error('Failed to write deployment script', ['exception' => $e->getMessage()]);
            return 'ERROR: Failed to generate the deployment script: ' . $e->getMessage();
        }

        $responseMessage = "SUCCESS: Deployment script '$deploymentScriptFilename' generated in the `generated_code` directory.\n\n";
        $responseMessage .= "PLEASE CAREFULLY REVIEW THE SCRIPT CONTENT AND THEN EXECUTE IT MANUALLY:\n";
        $responseMessage .= "1. Review the generated script: " . $deploymentScriptPath . "\n";
        $responseMessage .= "2. Execute the script from your project root: bash generated_code/" . $deploymentScriptFilename . "\n\n";

        if (!empty($successfulFiles)) {
            $responseMessage .= "Files prepared for deployment:\n";
            foreach ($successfulFiles as $file) {
                $responseMessage .= sprintf("- %s -> %s\n", $file['source_file'], $file['target_path']);
            }
        }

        if (!empty($failedFiles)) {
            $responseMessage .= "\nWARNING: The following files could not be prepared for deployment due to errors:\n";
            foreach ($failedFiles as $error) {
                $responseMessage .= "- $error\n";
            }
        }

        return $responseMessage;
    }
}
